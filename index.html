<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Delta Polygon Compressor</title>
<style>
  body { font-family: sans-serif; display:flex; flex-direction:column; align-items:center; gap:12px; margin:0; padding:16px; }
  canvas { border:1px solid #000; }
  textarea { width:600px; height:300px; }
  h1 { margin:0; }
</style>
</head>
<body>
<h1>Delta Polygon Compressor</h1>

<input type="file" id="folder-input" webkitdirectory directory multiple />
<canvas id="canvas" width="400" height="400"></canvas>
<textarea id="output" readonly placeholder="Compressed delta output will appear here"></textarea>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const outputEl = document.getElementById('output');

function encodeDeltas(points){
  if(points.length === 0) return [];
  let deltas = [points[0]];
  for(let i=1;i<points.length;i++){
    deltas.push([points[i][0]-points[i-1][0], points[i][1]-points[i-1][1]]);
  }
  return deltas;
}

function decodeDeltas(deltas){
  if(deltas.length === 0) return [];
  let pts = [deltas[0]];
  for(let i=1;i<deltas.length;i++){
    let last = pts[i-1];
    pts.push([last[0]+deltas[i][0], last[1]+deltas[i][1]]);
  }
  return pts;
}

async function processImageFile(file){
  return new Promise(resolve=>{
    const img = new Image();
    img.onload = async ()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Draw scaled down to reduce load
      ctx.drawImage(img,0,0,canvas.width,canvas.height);

      const mat = cv.imread(canvas);
      const gray = new cv.Mat();
      cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
      const thresh = new cv.Mat();
      cv.threshold(gray, thresh, 127, 255, cv.THRESH_BINARY);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let best = null, bestArea = 0;
      for(let i=0;i<contours.size();i++){
        const c = contours.get(i);
        const area = cv.contourArea(c);
        if(area > bestArea){ bestArea = area; best = c; }
      }

      let pts = [];
      if(best){
        for(let i=0;i<best.rows;i++){
          pts.push([best.intPtr(i,0)[0], best.intPtr(i,0)[1]]);
        }
      }

      const deltas = encodeDeltas(pts);
      const absPts = decodeDeltas(deltas).flat();

      mat.delete(); gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete(); 
      if(best) best.delete();

      resolve({frame: [{points: absPts, fill:"black"}]});
    };
    img.src = URL.createObjectURL(file);
  });
}

// Batch processing to prevent freezing
async function processFilesInBatches(files, batchSize = 5){
  const allFrames = [];
  for(let i = 0; i < files.length; i += batchSize){
    const batch = files.slice(i, i + batchSize);
    for(const file of batch){
      const {frame} = await processImageFile(file);
      allFrames.push(frame);
    }
    // Yield control to browser
    await new Promise(r => setTimeout(r, 20));
  }
  return allFrames;
}

// Folder input listener
document.getElementById('folder-input').addEventListener('change', async e=>{
  const files = Array.from(e.target.files)
    .filter(f=>f.name.endsWith('.png'))
    .sort((a,b)=>a.name.localeCompare(b.name));

  outputEl.value = "Processing " + files.length + " images...";
  const allFrames = await processFilesInBatches(files);
  outputEl.value = "Frames = " + JSON.stringify(allFrames, null, 2);
});

function onOpenCvReady(){ console.log('OpenCV.js ready'); }
if(window.cv) cv['onRuntimeInitialized'] = onOpenCvReady;
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Image Polygonizer</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #181818;
      color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
    }
    header {
      padding: 1em;
      font-size: 1.4em;
      font-weight: bold;
      text-align: center;
      background: #222;
      width: 100%;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    #controls {
      display: flex;
      gap: 1em;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      padding: 1em;
      background: #202020;
      border-bottom: 1px solid #333;
      width: 100%;
    }
    #controls label {
      display: flex;
      align-items: center;
      gap: 0.3em;
      font-size: 0.9em;
    }
    #main {
      display: flex;
      flex: 1;
      width: 100%;
      overflow: hidden;
    }
    #canvas-container, #code-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    canvas {
      flex: 1;
      background: #000;
      display: block;
      max-width: 100%;
      object-fit: contain;
    }
    textarea {
      flex: 1;
      background: #111;
      color: #0f0;
      font-family: monospace;
      border: none;
      resize: none;
      padding: 1em;
      overflow: auto;
      font-size: 0.85em;
    }
    button {
      background: #444;
      border: none;
      padding: 0.5em 1em;
      border-radius: 5px;
      cursor: pointer;
      color: #fff;
      transition: background 0.2s;
    }
    button:hover {
      background: #666;
    }
    input[type="number"] {
      width: 3em;
    }
  </style>
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
  <header>üñºÔ∏è Image ‚Üí Polygon Converter</header>
  
  <div id="controls">
    <input type="file" id="imageInput">
    <label>EPS % <input type="number" id="epsInput" value="2"></label>
    <label><input type="checkbox" id="colorToggle"> Color Mode</label>
    <label>Colors <input type="number" id="colorCount" value="8"></label>
    <button id="processBtn">Process</button>
  </div>
  
  <div id="main">
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
    <div id="code-container">
      <textarea id="codeOutput"></textarea>
    </div>
  </div>

  <script>
    const inputEl = document.getElementById('imageInput');
    const epsInput = document.getElementById('epsInput');
    const colorToggleEl = document.getElementById('colorToggle');
    const colorCountEl = document.getElementById('colorCount');
    const processBtn = document.getElementById('processBtn');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const codeOutput = document.getElementById('codeOutput');

    let img = new Image();

    inputEl.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    processBtn.addEventListener('click', () => {
      if (typeof cv === 'undefined') {
        alert('OpenCV not loaded yet');
        return;
      }
      processFrame();
    });

    function processFrame() {
      const mat = cv.imread(canvas);
      const polygonsOut = [];
      const epsPercent = parseFloat(epsInput.value) / 100.0;
      const canvasArea = mat.rows * mat.cols;

      if (colorToggleEl.checked) {
        // -------- COLOR MODE --------
        let samples = new cv.Mat(mat.rows * mat.cols, 3, cv.CV_32F);
        for (let y = 0; y < mat.rows; y++) {
          for (let x = 0; x < mat.cols; x++) {
            const px = mat.ucharPtr(y, x);
            const idx = y * mat.cols + x;
            samples.floatPtr(idx)[0] = px[0];
            samples.floatPtr(idx)[1] = px[1];
            samples.floatPtr(idx)[2] = px[2];
          }
        }

        let K = parseInt(colorCountEl.value);
        let labels = new cv.Mat();
        let centers = new cv.Mat();
        cv.kmeans(samples, K, labels,
          new cv.TermCriteria(cv.TermCriteria_EPS + cv.TermCriteria_MAX_ITER, 10, 1.0),
          3, cv.KMEANS_RANDOM_CENTERS, centers);

        centers.convertTo(centers, cv.CV_8U);

        for (let k = 0; k < K; k++) {
          let mask = cv.Mat.zeros(mat.rows, mat.cols, cv.CV_8UC1);
          for (let i = 0; i < labels.rows; i++) {
            if (labels.intAt(i, 0) === k) {
              mask.data[i] = 255;
            }
          }

          let clusterContours = new cv.MatVector();
          let clusterHierarchy = new cv.Mat();
          cv.findContours(mask, clusterContours, clusterHierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

          for (let i = 0; i < clusterContours.size(); i++) {
            const c = clusterContours.get(i);
            const area = cv.contourArea(c, false);
            if (area < 10) { c.delete(); continue; }
            if (area > 0.95 * canvasArea) { c.delete(); continue; }

            const peri = cv.arcLength(c, true);
            const eps = Math.max(1, epsPercent * peri);
            const approx = new cv.Mat();
            cv.approxPolyDP(c, approx, eps, true);

            let pts = [];
            for (let j = 0; j < approx.rows; j++) {
              const p = approx.data32S.subarray(j * 2, j * 2 + 2);
              pts.push([p[0], p[1]]);
            }
            if (pts.length) pts.push(pts[0]);

            const colorRGB = [
              centers.ucharAt(k, 0),
              centers.ucharAt(k, 1),
              centers.ucharAt(k, 2)
            ];

            polygonsOut.push({ pts, color: colorRGB });

            approx.delete();
            c.delete();
          }

          clusterContours.delete();
          clusterHierarchy.delete();
          mask.delete();
        }

        samples.delete(); labels.delete(); centers.delete();

      } else {
        // -------- MONO MODE --------
        let gray = new cv.Mat();
        cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
        cv.threshold(gray, gray, 127, 255, cv.THRESH_BINARY);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        for (let i = 0; i < contours.size(); i++) {
          const c = contours.get(i);
          const area = cv.contourArea(c, false);
          if (area < 10) { c.delete(); continue; }
          if (area > 0.95 * canvasArea) { c.delete(); continue; }

          const peri = cv.arcLength(c, true);
          const eps = Math.max(1, epsPercent * peri);
          const approx = new cv.Mat();
          cv.approxPolyDP(c, approx, eps, true);

          let pts = [];
          for (let j = 0; j < approx.rows; j++) {
            const p = approx.data32S.subarray(j * 2, j * 2 + 2);
            pts.push([p[0], p[1]]);
          }
          if (pts.length) pts.push(pts[0]);

          polygonsOut.push({ pts, color: 'black' });

          approx.delete();
          c.delete();
        }

        contours.delete();
        hierarchy.delete();
        gray.delete();
      }

      mat.delete();

      // -------- EXPORT CODE --------
      let code = '';
      polygonsOut.forEach(poly => {
        if (!poly.pts.length) return;

        code += 'Polygon(';
        poly.pts.forEach(([x, y], i) => {
          code += `${Math.round(x)},${Math.round(y)}${i < poly.pts.length - 1 ? ',' : ''}`;
        });

        if (Array.isArray(poly.color)) {
          code += `, fill=rgb(${poly.color[0]},${poly.color[1]},${poly.color[2]}))\n`;
        } else {
          code += `, fill=rgb(0,0,0))\n`;
        }
      });

      codeOutput.value = code;
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image to CMU Polygon Code</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
      flex-direction: column;
    }
    #canvas {
      border: 1px solid black;
      margin-bottom: 20px;
    }
    #output-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #output {
      white-space: pre-wrap;
      font-family: monospace;
      width: 100%;
      max-width: 500px;
      height: 200px;
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid #ccc;
      overflow: auto;
      background-color: #fafafa;
    }
    #copy-button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
    }
    #copy-button:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>

  <div>
    <h1>Convert Image to CMU Polygon Code</h1>
    <input type="file" id="file-input" accept="image/*" />
    <canvas id="canvas" width="400" height="400"></canvas>

    <div id="output-container">
      <textarea id="output" readonly></textarea>
      <button id="copy-button">Copy Code</button>
    </div>
  </div>

  <script>
    function onOpenCvReady() {
      console.log("OpenCV.js is ready.");
    }

    document.getElementById('file-input').addEventListener('change', function (e) {
      let file = e.target.files[0];
      let reader = new FileReader();
      reader.onload = function(event) {
        let img = new Image();
        img.onload = function() {
          let canvas = document.getElementById('canvas');
          let ctx = canvas.getContext('2d');
          
          let imageWidth = img.width;
          let imageHeight = img.height;

          let scaleX = canvas.width / imageWidth;
          let scaleY = canvas.height / imageHeight;
          let scale = Math.min(scaleX, scaleY);

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          let scaledWidth = imageWidth * scale;
          let scaledHeight = imageHeight * scale;
          let offsetX = (canvas.width - scaledWidth) / 2;
          let offsetY = (canvas.height - scaledHeight) / 2;
          ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);

          // OpenCV processing
          let mat = cv.imread(canvas);
          let gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

          // Use simple global thresholding instead of adaptive
          let thresholded = new cv.Mat();
          cv.threshold(gray, thresholded, 127, 255, cv.THRESH_BINARY);

          // Find contours
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(thresholded, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

          // Select the largest contour
          let largestContour = null;
          let maxArea = 0;
          for (let i = 0; i < contours.size(); i++) {
            let contour = contours.get(i);
            let area = cv.contourArea(contour);
            if (area > maxArea) {
              maxArea = area;
              largestContour = contour;
            }
          }

          // Approximate largest contour
          let approx = new cv.Mat();
          if (largestContour) {
            let peri = cv.arcLength(largestContour, true);
            cv.approxPolyDP(largestContour, approx, 0.01 * peri, true);
          }

          // Convert to JS array
          let allPoints = [];
          for (let j = 0; j < approx.rows; j++) {
            let point = approx.data32S.subarray(j * 2, j * 2 + 2);
            allPoints.push([point[0], point[1]]);
          }

          // Scale & round
          allPoints = allPoints.map(([x, y]) => [
            Math.round(x), 
            Math.round(y)
          ]);

          // Ensure polygon is closed
          if (allPoints.length > 0) {
            allPoints.push(allPoints[0]);
          }

          // Generate CMU Polygon Code
          let polygonCode = `Polygon(`;
          allPoints.forEach(([x, y], i) => {
            polygonCode += `${x},${y}`;
            if (i < allPoints.length - 1) {
              polygonCode += ',';
            }
          });
          polygonCode += `, fill='black')\n`;

          // Show output
          document.getElementById('output').value = polygonCode;

          // Cleanup
          mat.delete(); gray.delete(); thresholded.delete();
          hierarchy.delete(); contours.delete(); approx.delete();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    if (cv.getBuildInformation) {
      cv.onRuntimeInitialized = onOpenCvReady;
    }

    document.getElementById('copy-button').addEventListener('click', function() {
      let output = document.getElementById('output');
      output.select();
      document.execCommand('copy');
      alert('Code copied to clipboard!');
    });
  </script>
</body>
</html>

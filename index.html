<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Polygonize Image</title>
  <style>
    body { font-family: monospace; background: #111; color: #eee; }
    #controls { margin-bottom: 1em; }
    textarea { width: 100%; height: 300px; }
    canvas { max-width: 100%; }
  </style>
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
  <div id="controls">
    <input type="file" id="imageInput">
    <label>EPS %: <input type="number" id="epsInput" value="2"></label>
    <label><input type="checkbox" id="colorToggle"> Color Mode</label>
    <label>Colors: <input type="number" id="colorCount" value="8"></label>
    <button id="processBtn">Process</button>
  </div>
  <canvas id="canvas"></canvas>
  <textarea id="codeOutput"></textarea>

  <script>
    const inputEl = document.getElementById('imageInput');
    const epsInput = document.getElementById('epsInput');
    const colorToggleEl = document.getElementById('colorToggle');
    const colorCountEl = document.getElementById('colorCount');
    const processBtn = document.getElementById('processBtn');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const codeOutput = document.getElementById('codeOutput');

    let img = new Image();

    inputEl.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    processBtn.addEventListener('click', () => {
      if (typeof cv === 'undefined') {
        alert('OpenCV not loaded yet');
        return;
      }
      processFrame();
    });

    function processFrame() {
      const mat = cv.imread(canvas);
      const polygonsOut = [];
      const epsPercent = parseFloat(epsInput.value) / 100.0;
      const canvasArea = mat.rows * mat.cols;

      if (colorToggleEl.checked) {
        // -------- COLOR QUANTIZATION MODE --------
        let samples = new cv.Mat(mat.rows * mat.cols, 3, cv.CV_32F);
        for (let y = 0; y < mat.rows; y++) {
          for (let x = 0; x < mat.cols; x++) {
            const px = mat.ucharPtr(y, x);
            const idx = y * mat.cols + x;
            samples.floatPtr(idx)[0] = px[0];
            samples.floatPtr(idx)[1] = px[1];
            samples.floatPtr(idx)[2] = px[2];
          }
        }

        let K = parseInt(colorCountEl.value);
        let labels = new cv.Mat();
        let centers = new cv.Mat();
        cv.kmeans(samples, K, labels,
          new cv.TermCriteria(cv.TermCriteria_EPS + cv.TermCriteria_MAX_ITER, 10, 1.0),
          3, cv.KMEANS_RANDOM_CENTERS, centers);

        centers.convertTo(centers, cv.CV_8U);

        for (let k = 0; k < K; k++) {
          let mask = cv.Mat.zeros(mat.rows, mat.cols, cv.CV_8UC1);
          for (let i = 0; i < labels.rows; i++) {
            if (labels.intAt(i, 0) === k) {
              mask.data[i] = 255;
            }
          }

          let clusterContours = new cv.MatVector();
          let clusterHierarchy = new cv.Mat();
          cv.findContours(mask, clusterContours, clusterHierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

          for (let i = 0; i < clusterContours.size(); i++) {
            const c = clusterContours.get(i);
            const area = cv.contourArea(c, false);
            if (area < 10) { c.delete(); continue; }
            if (area > 0.95 * canvasArea) { c.delete(); continue; }

            const peri = cv.arcLength(c, true);
            const eps = Math.max(1, epsPercent * peri);
            const approx = new cv.Mat();
            cv.approxPolyDP(c, approx, eps, true);

            let pts = [];
            for (let j = 0; j < approx.rows; j++) {
              const p = approx.data32S.subarray(j * 2, j * 2 + 2);
              pts.push([p[0], p[1]]);
            }
            if (pts.length) pts.push(pts[0]);

            const colorRGB = [
              centers.ucharAt(k, 0),
              centers.ucharAt(k, 1),
              centers.ucharAt(k, 2)
            ];

            polygonsOut.push({ pts, color: colorRGB });

            approx.delete();
            c.delete();
          }

          clusterContours.delete();
          clusterHierarchy.delete();
          mask.delete();
        }

        samples.delete(); labels.delete(); centers.delete();

      } else {
        // -------- MONO MODE --------
        let gray = new cv.Mat();
        cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
        cv.threshold(gray, gray, 127, 255, cv.THRESH_BINARY);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        for (let i = 0; i < contours.size(); i++) {
          const c = contours.get(i);
          const area = cv.contourArea(c, false);
          if (area < 10) { c.delete(); continue; }
          if (area > 0.95 * canvasArea) { c.delete(); continue; }

          const peri = cv.arcLength(c, true);
          const eps = Math.max(1, epsPercent * peri);
          const approx = new cv.Mat();
          cv.approxPolyDP(c, approx, eps, true);

          let pts = [];
          for (let j = 0; j < approx.rows; j++) {
            const p = approx.data32S.subarray(j * 2, j * 2 + 2);
            pts.push([p[0], p[1]]);
          }
          if (pts.length) pts.push(pts[0]);

          polygonsOut.push({ pts, color: 'black' });

          approx.delete();
          c.delete();
        }

        contours.delete();
        hierarchy.delete();
        gray.delete();
      }

      mat.delete();

      // -------- EXPORT CODE --------
      let code = '';
      polygonsOut.forEach(poly => {
        if (!poly.pts.length) return;

        code += 'Polygon(';
        poly.pts.forEach(([x, y], i) => {
          code += `${Math.round(x)},${Math.round(y)}${i < poly.pts.length - 1 ? ',' : ''}`;
        });

        if (Array.isArray(poly.color)) {
          code += `, fill=rgb(${poly.color[0]},${poly.color[1]},${poly.color[2]}))\n`;
        } else {
          if (poly.color === 'black') {
            code += `, fill=rgb(0,0,0))\n`;
          } else {
            code += `, fill=${poly.color})\n`;
          }
        }
      });

      codeOutput.value = code;
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image to CMU Polygon Code</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }
    #canvas {
      border: 1px solid black;
    }
    #output {
      white-space: pre-wrap;
      margin-top: 20px;
      font-family: monospace;
    }
  </style>
</head>
<body>

  <div>
    <h1>Convert Image to CMU Polygon Code</h1>
    <input type="file" id="file-input" accept="image/*" />
    <canvas id="canvas" width="500" height="500"></canvas>
    <pre id="output"></pre>
  </div>

  <script>
    function onOpenCvReady() {
      console.log("OpenCV.js is ready.");
    }

    document.getElementById('file-input').addEventListener('change', function (e) {
      let file = e.target.files[0];
      let reader = new FileReader();
      reader.onload = function(event) {
        let img = new Image();
        img.onload = function() {
          // Get canvas and context
          let canvas = document.getElementById('canvas');
          let ctx = canvas.getContext('2d');
          
          // Scale the image to fit the canvas size, maintaining aspect ratio
          let canvasWidth = canvas.width;
          let canvasHeight = canvas.height;
          let imageWidth = img.width;
          let imageHeight = img.height;

          let scale = Math.min(canvasWidth / imageWidth, canvasHeight / imageHeight);
          let scaledWidth = imageWidth * scale;
          let scaledHeight = imageHeight * scale;

          // Clear the canvas before drawing
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);

          // Draw the scaled image onto the canvas
          let offsetX = (canvasWidth - scaledWidth) / 2;
          let offsetY = (canvasHeight - scaledHeight) / 2;
          ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);

          // Create a Mat from the image for OpenCV processing
          let mat = cv.imread(canvas);
          let gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

          // Apply edge detection (Canny)
          let edges = new cv.Mat();
          cv.Canny(gray, edges, 100, 200);

          // Find contours in the edge-detected image
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

          // Merge all contours into one large contour (if possible)
          let allPoints = [];
          for (let i = 0; i < contours.size(); i++) {
            let contour = contours.get(i);
            for (let j = 0; j < contour.rows; j++) {
              let point = contour.data32S.subarray(j * 2, j * 2 + 2);
              allPoints.push([point[0], point[1]]);
            }
          }

          // Approximate the entire edge shape into a single polygon
          let allPointsMat = cv.matFromArray(allPoints.length, 1, cv.CV_32SC2, new Int32Array(allPoints.flat()));
          let approx = new cv.Mat();
          cv.approxPolyDP(allPointsMat, approx, 3, true);

          // Convert Mat to JS array for easy processing
          let polygon = [];
          for (let j = 0; j < approx.rows; j++) {
            let point = approx.data32S.subarray(j * 2, j * 2 + 2);
            polygon.push([point[0], point[1]]);
          }

          // Scale and translate polygon to fit the canvas size
          let scaledPolygon = polygon.map(([x, y]) => {
            let scaledX = offsetX + x * scale;
            let scaledY = offsetY + y * scale;
            return [scaledX, scaledY];
          });

          // Generate CMU Polygon Code (formatted output)
          let polygonCode = `Polygon(`;
          scaledPolygon.forEach(([x, y], i) => {
            polygonCode += `${x},${y}`;
            if (i < scaledPolygon.length - 1) {
              polygonCode += ','; // Add comma between coordinates
            }
          });
          polygonCode += `, fill='black')\n`; // Add the fill attribute at the end

          // Display the result in the output section
          document.getElementById('output').textContent = polygonCode;

          // Clean up OpenCV Mat objects to avoid memory leaks
          mat.delete();
          gray.delete();
          edges.delete();
          hierarchy.delete();
          contours.delete();
          allPointsMat.delete();
          approx.delete();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    if (cv.getBuildInformation) {
      cv.onRuntimeInitialized = onOpenCvReady;
    }
  </script>
</body>
</html>
